.step(data-file='app/controllers/users_controller.rb', data-highlight='6-22')
  :markdown
    ## Registering a User with Authy

    When a new User signs up for our website, we call this controller, which 
    handles saving our new User to the database as well as registering the User 
    with Authy.

    All Authy needs to get a user set up for your application is the email, 
    phone number and country code. In order to do two-factor authentication, 
    we need to make sure we ask for these things at the point of sign up.

    Once we register the User with Authy we get an `authy_id` back. This is 
    very important since it's how we will verify the identity of our User with 
    Authy.

    ---

    **See Also:**
    * [Looking up an ActiveRecord object](//guides.rubyonrails.org/active_record_querying.html#retrieving-a-single-object)
    * [Enabling a User with Authy](//docs.authy.com/#section-Enabling_two-factor_on_a_user)
    * [All about Rails Sessions](//guides.rubyonrails.org/action_controller_overview.html#session)

.step(data-file='app/controllers/sessions_controller.rb', data-highlight='6-29')
  :markdown
    ## Logging in with Authy OneTouch

    When a User attempts to log in to our website, we will ask them for a second 
    form of identification. Let's take a look at OneTouch verification first. 

    ![Authy OneTouch Approval](//howtodocs.s3.amazonaws.com/onetouch-approved.gif)

    OneTouch works like so:
    * We attempt to send a User a _OneTouch Approval Request_
    * If the User has OneTouch enabled, we will get a `success` message back
    * The User hits 'Approve' in their Authy app
    * Authy makes a POST request to our app with an 'Approved' status
    * We log the User in

    In the next steps we'll look at how we handle cases where the User does not 
    have OneTouch, or denies the login request.

.step(data-file='app/controllers/sessions_controller.rb', data-highlight='11-21')
  :markdown
    ## Sending the OneTouch Request

    When our User logs in we immediately attempt to verify their identity with 
    OneTouch. We will fallback gracefully if they don't have a OneTouch device, 
    but we don't know until we try.

    Authy lets us pass details with our OneTouch request, including a message, 
    a logo and any other details we want to send. We could easily send any 
    number of details by appending `details['some_detail']`. You could imagine a 
    scenario where we send a OneTouch request to approve a money transfer:

    ```ruby
    "message" => "Request to Send Money to Jarod's vault",
    "details['Request From']" => "Jarod",
    "details['Amount Request']" => "1,000,000",
    "details['Currency']" => "Galleons",
    ```
    Once we send the request we need to update our User's `authy_status` based 
    on the response.

    --- 

    **See Also:**
    * [NET::HTTP gem cheatsheet](https://github.com/augustl/net-http-cheat-sheet/blob/master/post_form.rb)
    * [ActiveRecord: Enums](//edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html)

.step(data-file='app/controllers/authy_controller.rb', data-highlight='11-22, 49-72, 5-7')
  :markdown
    ## Configuring the OneTouch callback

    In order for our app to know what the User did after we sent the OneTouch 
    request, we need to register a callback endpoint with Authy.

    ![Authy OneTouch Callback](//howtodocs.s3.amazonaws.com/onetouch-callback-endpoint.png)

    *Note: In order to verify that the request is coming from Authy we've written a filter that will halt the request if it appears it isn't coming from Authy.*

    Here in our callback, we look up the user using the `authy_id` sent with the Authy POST request. Ideally at this point we would probably use a websocket to let our client know that we received a response from Authy. However for this version we're going to keep it simple and just update the `authy_status` on the User. Then all our client-side code needs to do is check for `user.authy_status.approved` before logging her in.


    Let's take a look at the client-side code that will be handling this.

    --- 

    **See Also:**
    * [ActiveRecord find_by!](//guides.rubyonrails.org/active_record_querying.html#find-by)

.step(data-file='app/assets/javascripts/sessions.js')
  :markdown
    ## Handling Two-Factor Asyncronously

    In order for two-factor authentication to be seamless, it is best done 
    asynchronously so that the user doesn't even know it's happening.

    We've already taken a look at what's happening on the server side, so let's 
    step in front of the cameras now and see how our JavaScript is interacting 
    with those server endpoints.

    First we hijack the login form submit and pass the data to our `sessions/create` 
    controller using Ajax. Depending on how that endpoint responds we will 
    either ask the User for token or await their OneTouch response.

    If we expect a OneTouch response, we will begin polling `/authy/status` until 
    we either see OneTouch login was either approved or denied. Let's take a 
    look at this controller and see what is happening.

    --- 

    **See Also:**
    * [jQuery Post method](//api.jquery.com/jquery.post/)
    * [Bootstrap modals](//getbootstrap.com/javascript/#modals)

.step(data-file='app/controllers/authy_controller.rb', data-highlight='24-28')
  :markdown
    ## Falling back to Token

    Here is the endpoint that our javascript is polling. It is waiting for the 
    user status to be either 'Approved' or 'Denied'. If the User has approved 
    the OneTouch request, we will store their id in the session, which 
    officially logs them in.

    If the request was denied we will ask the User to log in with a Token.
    
    --- 

    **See Also:**
    * [Rails: Using render](//guides.rubyonrails.org/layouts_and_rendering.html#using-render)

.step(data-title='The 2FA Step', data-file='app/controllers/authy_controller.rb', data-highlight='30-47')

  :markdown
    ## Sending a Token

    These two route handlers are responsible for sending the token, and then 
    validating the code that they entered.

    In the case where our User already has the Authy app, but is not enabled for 
    OneTouch this same method will trigger a push notification that will be sent 
    to their phone, with a code inside the Authy app.

    A verification form will pop up over the login form. The verification form 
    will look something like this to the end user:

    ![The Verification Form](//s3.amazonaws.com/howtodocs/2fa-screen-verify.png)

    The `verify` method is responsible for validating the token sent to our user 
    via SMS.  First, we grab the `User` model by the ID we stored in the session 
    during the previous step in `pre_2fa_auth_user_id`.  Next, we use the Authy 
    API to validate the token our user entered against the one Authy sent them.  
    If the two match, our login process is complete!  We store the user's 
    database ID in the session object as `user_id`, which we use to indicate 
    that the user has sucessfully logged in to our application.

.step
  :markdown
    ## Where to next?

    That's it! We've just implemented two-factor auth using three different 
    methods and the latest in Authy technology.

    If you're a Ruby developer working with Twilio, you might enjoy these
    other tutorials:

    [**Masked Phone Numbers**](//www.twilio.com/docs/howto/walkthrough/masked-numbers/ruby/rails)

    Protect your users' privacy by anonymously connecting them with Twilio Voice 
    and SMS. Learn how to create disposable phone numbers on-demand, so two 
    users can communicate without exchanging personal information.

    [**Call Tracking**](h//www.twilio.com/docs/howto/walkthrough/call-tracking/ruby/rails)

    Use Twilio to track the effectiveness of your marketing campaigns.

    ### Did this help?

    Thanks for checking out this tutorial! If you have any feedback to share
    with us, we'd love to hear it. Tweet
    [@twilio](http://twitter.com/twilio) to let us know what you think.
